递归实现
---

  建立2个数组，一个记录是所有点否已遍历，另一个记录当前遍历点得顺序，然后各个点遍历


非递归实现
---

基本思想是:

   1. 找到所有排列中最小的一个排列P.
   2. 找到刚刚好比P大比其它都小的排列Q,
   3. 循环执行第二步,直到找到一个最大的排列,算法结束.    
    
下面用数学的方法描述:

  给定已知序列 P =  A1A2A3An ( Ai!=Aj , (1<=i<=n  , 1<=j<=n, i != j  ) )
  找到P的一个最小排列Pmin = P1P2P3Pn  有  Pi > P(i-1) (1 < i <= n)
  从Pmin开始,总是目前得到的最大的排列为输入,得到下一个排列.

方法为:

  1. 从低位到高位（从后向前），找出“不符合趋势”的数字。即找到一个Pi，使Pi < P(i+1)。
  	若找不到这样的pi，说明我们已经找到最后一个全排列，可以返回了。
  
  2. 在 P(i+1)P(i+2)Pn 中,找到一个Pj,便得 Pj"刚刚好大于"Pi.
  ("刚刚好大于"的意思是:在 P(i+1)P(i+2)Pn 中所有大于Pi的元素构成的集合中最小的元素.)
  
  3. 交换 Pi , Pj 的位置.注意:此处不改变i和j的值,改变的是Pi和Pj.

  4. 交换后， P1P2P3Pn  并不是准确的后一个排列。因为根据第1步的查找，我们有P(i+1) > P(i+2) > . > Pn
  即使进行了Pi和Pj的交换,这仍然是这一部分最大的一个排列。将此排列逆序倒置(变成最小的排列)即为所求的下一个排列.
  
  5. 重复步骤1-4,直到步骤1中找不到“不符合趋势”的数字.